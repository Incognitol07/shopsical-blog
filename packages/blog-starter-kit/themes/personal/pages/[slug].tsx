import { resizeImage } from '@starter-kit/utils/image';
import { addArticleJsonLd } from '@starter-kit/utils/seo/addArticleJsonLd';
import { getAutogeneratedPostOG } from '@starter-kit/utils/social/og';
// @ts-ignore
import handleMathJax from '@starter-kit/utils/handle-math-jax';
import { SEO_CONFIG, generateArticleKeywords } from '../lib/seo-config';
import { useEmbeds } from '@starter-kit/utils/renderer/hooks/useEmbeds';
import { loadIframeResizer } from '@starter-kit/utils/renderer/services/embed';
import request from 'graphql-request';
import { GetStaticProps } from 'next';
import Head from 'next/head';
import Link from 'next/link';
import Image from 'next/image';
import { useEffect, useState } from 'react';
import { Clock, Calendar } from 'lucide-react';
import { Container } from '../components/container';
import { AppProvider } from '../components/contexts/appContext';
import { DateFormatter } from '../components/date-formatter';
import { Layout } from '../components/layout';
import { MarkdownToHtml } from '../components/markdown-to-html';
import { Avatar, AvatarFallback, AvatarImage } from '../components/ui/avatar';
import { Badge } from '../components/ui/badge';
import { Dialog, DialogContent } from '../components/ui/dialog';
import { TableOfContents } from '../components/blog/TableOfContents';
import { AuthorBio } from '../components/blog/AuthorBio';
import { ShareButtons } from '../components/blog/ShareButtons';
import {
	PageByPublicationDocument,
	PostFullFragment,
	PublicationFragment,
	SinglePostByPublicationDocument,
	SlugPostsByPublicationDocument,
	StaticPageFragment,
} from '../generated/graphql';
// @ts-ignore
import { triggerCustomWidgetEmbed } from '@starter-kit/utils/trigger-custom-widget-embed';

type PostProps = {
	type: 'post';
	post: PostFullFragment;
	publication: PublicationFragment;
};

type PageProps = {
	type: 'page';
	page: StaticPageFragment;
	publication: PublicationFragment;
};

type Props = PostProps | PageProps;

const Post = ({ publication, post }: PostProps) => {
	const highlightJsMonokaiTheme =
		'.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}';
	const [, setMobMount] = useState(false);
	const [canLoadEmbeds, setCanLoadEmbeds] = useState(false);
	const [imageDialogOpen, setImageDialogOpen] = useState(false);
	useEmbeds({ enabled: canLoadEmbeds });

	if (post.hasLatexInPost) {
		setTimeout(() => {
			handleMathJax(true);
		}, 500);
	}

	useEffect(() => {
		if (screen.width <= 425) {
			setMobMount(true);
		}

		if (!post) {
			return;
		}

		(async () => {
			await loadIframeResizer();
			triggerCustomWidgetEmbed(post.publication?.id.toString());
			setCanLoadEmbeds(true);
		})();
	}, [post]);

	const coverImageSrc = !!post.coverImage?.url
		? resizeImage(post.coverImage.url, {
				w: 1600,
				h: 840,
				c: 'thumb',
		  })
		: undefined;

	return (
		<>
			<Head>
				<title>{post.seo?.title || `${post.title} | ${SEO_CONFIG.site.name}`}</title>
				<link rel="canonical" href={post.url} />
				<meta name="description" content={post.seo?.description || post.subtitle || post.brief} />
				<meta name="author" content={post.author?.name} />
				<meta name="article:published_time" content={post.publishedAt} />
				{post.updatedAt && <meta name="article:modified_time" content={post.updatedAt} />}
				<meta name="keywords" content={generateArticleKeywords(post.tags?.map((tag: any) => tag.name) || [])} />
				
				<meta property="og:type" content="article" />
				<meta property="og:url" content={post.url} />
				<meta property="og:site_name" content={SEO_CONFIG.openGraph.siteName} />
				<meta property="og:title" content={post.seo?.title || post.title} />
				<meta property="og:description" content={post.seo?.description || post.subtitle || post.brief} />
				<meta property="og:image" content={post.ogMetaData?.image || post.coverImage?.url || `${SEO_CONFIG.site.baseUrl}${SEO_CONFIG.assets.ogImageDefault}`} />
				
				<meta name="twitter:card" content={SEO_CONFIG.twitter.card} />
				<meta name="twitter:title" content={post.seo?.title || post.title} />
				<meta name="twitter:description" content={post.seo?.description || post.subtitle || post.brief} />
				<meta name="twitter:image" content={post.ogMetaData?.image || post.coverImage?.url || `${SEO_CONFIG.site.baseUrl}${SEO_CONFIG.assets.ogImageDefault}`} />
				
				<script
					type="application/ld+json"
					dangerouslySetInnerHTML={{
						__html: JSON.stringify(addArticleJsonLd(publication, post, SEO_CONFIG)),
					}}
				/>
				<style dangerouslySetInnerHTML={{ __html: highlightJsMonokaiTheme }}></style>
			</Head>

			{/* Article Header */}
			<div className="pt-6 sm:pt-10 pb-8 px-4 sm:px-6 lg:px-8 bg-background">
				<Container className="max-w-4xl">
					<div className="space-y-6">
						{/* Tags */}
						{post.tags && post.tags.length > 0 && (
							<div className="flex gap-2 flex-wrap">
								{post.tags.slice(0, 3).map((tag) => (
									<Link key={tag.id} href={`/tag/${tag.slug}`}>
										<Badge variant="secondary" className="bg-primary/10 text-primary hover:bg-primary/20 border-none rounded-full px-3 py-1 uppercase tracking-wider text-xs font-bold">
											{tag.name}
										</Badge>
									</Link>
								))}
							</div>
						)}

						{/* Title */}
						<h1 className="text-4xl sm:text-5xl lg:text-6xl font-extrabold text-foreground leading-tight tracking-tight">
							{post.title}
						</h1>

						{/* Subtitle */}
						{post.subtitle && (
							<p className="text-xl sm:text-2xl text-muted-foreground leading-relaxed font-light">
								{post.subtitle}
							</p>
						)}

						{/* Author and Meta */}
						<div className="flex items-center gap-6 py-6 border-y border-border">
							<div className="flex items-center gap-3">
								<Avatar className="h-12 w-12 border border-border">
									<AvatarImage src={post.author.profilePicture || ''} alt={post.author.name} />
									<AvatarFallback className="bg-primary/10 text-primary font-bold">
										{post.author.name.charAt(0)}
									</AvatarFallback>
								</Avatar>
								<div>
									<div className="text-foreground font-bold">{post.author.name}</div>
									<div className="text-muted-foreground text-sm">@{post.author.username}</div>
								</div>
							</div>

							<div className="h-8 w-px bg-border hidden sm:block"></div>

							<div className="flex items-center gap-6 text-muted-foreground text-sm font-medium">
								<div className="flex items-center gap-2">
									<Calendar className="w-4 h-4 text-primary" />
									<DateFormatter dateString={post.publishedAt} />
								</div>
								<div className="flex items-center gap-2">
									<Clock className="w-4 h-4 text-primary" />
									<span>{post.readTimeInMinutes} min read</span>
								</div>
							</div>

							<div className="ml-auto w-full sm:w-auto mt-4 sm:mt-0">
								<ShareButtons url={post.url} title={post.title} />
							</div>
						</div>
					</div>
				</Container>
			</div>

			{/* Cover Image */}
			{coverImageSrc && (
				<Container className="max-w-5xl px-4 sm:px-6 lg:px-8 mb-12">
					<div 
						className="relative h-[250px] sm:h-[600px] w-full cursor-pointer overflow-hidden rounded-2xl shadow-lg"
						onClick={() => setImageDialogOpen(true)}
					>
						<Image
							src={coverImageSrc}
							alt={post.title}
							fill
							className="object-cover hover:scale-105 transition-transform duration-700"
							priority
						/>
					</div>
				</Container>
			)}

			{/* Content Section */}
			<Container className="max-w-4xl px-4 sm:px-6 lg:px-8 pb-16">
				<div className={`grid grid-cols-1 gap-12 ${post.features.tableOfContents.isEnabled && post.features.tableOfContents.items.length > 0 ? 'lg:grid-cols-12' : ''}`}>
					{/* Main Content */}
					<article className={post.features.tableOfContents.isEnabled && post.features.tableOfContents.items.length > 0 ? 'lg:col-span-8' : 'mx-auto max-w-4xl'}>
						<div className="prose max-w-none prose-headings:font-bold prose-headings:tracking-tight prose-a:text-primary hover:prose-a:text-primary-dark prose-img:rounded-xl">
							<MarkdownToHtml contentMarkdown={post.content.markdown} />
						</div>

						{/* Tags Section */}
						{(post.tags ?? []).length > 0 && (
							<div className="mt-12 pt-8 border-t border-border">
								<h3 className="text-lg font-bold text-foreground mb-4">Posted in</h3>
								<div className="flex flex-wrap gap-2">
									{post.tags!.map((tag) => (
										<Link key={tag.id} href={`/tag/${tag.slug}`}>
											<Badge variant="outline" className="border-border text-muted-foreground hover:bg-accent hover:text-accent-foreground px-4 py-2 text-sm">
												#{tag.slug}
											</Badge>
										</Link>
									))}
								</div>
							</div>
						)}

						{/* Author Bio */}
						{/* <div className="mt-12 p-8 bg-accent-1 rounded-2xl">
							<AuthorBio
								name={post.author.name}
								username={post.author.username}
								profilePicture={post.author.profilePicture}
							/>
						</div> */}
					</article>

					{/* Sidebar */}
					{post.features.tableOfContents.isEnabled && post.features.tableOfContents.items.length > 0 && (
						<aside className="lg:col-span-4 lg:sticky lg:top-32 h-fit hidden lg:block">
							<div className="bg-card-bg border border-border rounded-xl p-6">
								<h3 className="font-bold text-foreground mb-4">Table of Contents</h3>
								<TableOfContents items={post.features.tableOfContents.items} />
							</div>
						</aside>
					)}
				</div>
			</Container>

			{/* Image Lightbox Dialog */}
			<Dialog open={imageDialogOpen} onOpenChange={setImageDialogOpen}>
				<DialogContent className="max-w-7xl w-full p-0 bg-transparent border-none shadow-none">
					{coverImageSrc && (
						<div className="relative w-full h-[90vh]">
							<Image
								src={coverImageSrc}
								alt={post.title}
								fill
								className="object-contain"
							/>
						</div>
					)}
				</DialogContent>
			</Dialog>
		</>
	);
};

const Page = ({ page }: PageProps) => {
	const title = page.title;
	return (
		<>
			<Head>
				<title>{title}</title>
			</Head>
			<Container className="max-w-4xl mx-auto py-10 px-5">
				<h1 className="text-4xl font-bold mb-8 text-foreground">{title}</h1>
				<div className="prose prose-lg prose-slate max-w-none">
					<MarkdownToHtml contentMarkdown={page.content.markdown} />
				</div>
			</Container>
		</>
	);
};

export default function PostOrPage(props: Props) {
	const maybePost = props.type === 'post' ? props.post : null;
	const maybePage = props.type === 'page' ? props.page : null;
	const publication = props.publication;

	return (
		<AppProvider publication={publication} post={maybePost} page={maybePage}>
			<Layout>
				{props.type === 'post' && <Post {...props} />}
				{props.type === 'page' && <Page {...props} />}
			</Layout>
		</AppProvider>
	);
}

type Params = {
	slug: string;
};

export const getStaticProps: GetStaticProps<Props, Params> = async ({ params }) => {
	if (!params) {
		throw new Error('No params');
	}

	const endpoint = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;
	const host = process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST;
	const slug = params.slug;

	const postData = await request(endpoint, SinglePostByPublicationDocument, { host, slug });

	if (postData.publication?.post) {
		return {
			props: {
				type: 'post',
				post: postData.publication.post,
				publication: postData.publication,
			},
			revalidate: 1,
		};
	}

	const pageData = await request(endpoint, PageByPublicationDocument, { host, slug });

	if (pageData.publication?.staticPage) {
		return {
			props: {
				type: 'page',
				page: pageData.publication.staticPage,
				publication: pageData.publication,
			},
			revalidate: 1,
		};
	}

	return {
		notFound: true,
		revalidate: 1,
	};
};

export async function getStaticPaths() {
	const data = await request(
		process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT,
		SlugPostsByPublicationDocument,
		{
			first: 10,
			host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
		},
	);

	const postSlugs = (data.publication?.posts.edges ?? []).map((edge) => edge.node.slug);

	return {
		paths: postSlugs.map((slug) => {
			return {
				params: {
					slug: slug,
				},
			};
		}),
		fallback: 'blocking',
	};
}
